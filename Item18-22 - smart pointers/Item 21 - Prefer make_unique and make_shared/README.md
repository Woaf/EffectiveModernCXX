# Prefer `std::make_unique` and `std::make_shared` to direct use of `new`

So far we only worked with calling the direct constructor of the standard unique pointer and the shared pointer, however C++14 allows us to use `std::make_unique` and `std::make_shared` for unique and shared pointers respectively. (Unfortunately, `std::make_unique` is not part of C++11, however we already created our own make_unique factory functions in the previous chapters.)

`std::make_unique` does not support custom deleters. 

There are several adavantages of using the make methods.
1) The first difference is straightforwad. Suppose we have the following code: 

```
std::unique_ptr<T> up1 (new T);
// vs.
auto up2 (std::make_uniuqe<T> ());
```
and 
```
std::shared_ptr<T> sp1 (new T);
// vs.
auto sp2 (std::make_shared<T> ());
```

As we can see, we do not repeat the type parameter declaration if we use the make methods. Repeating the types could lead to some problems, especially if inheritence comes into play. (Or just simply put: do not duplicate code.)

2) The second argument is exception safety. 

Suppose we pass an `std::shared_ptr<T>` by value to a function. We can write it in two ways: 
```
processT (std::shared_ptr<T> (new T (...)), compute ());
// vs.
processT (std::make_shared<T> (...), compute ());
```

The problem with the code in the first case comes from the object code that is generated by the compiler. The function arguments must be evaluated before the function is invoked, but the order of evaluation depends entirely on the compiler. It would be possible for `new T` to run first, then `compute ()`, then the constructor of the shared / unique pointer. In this case, the new object will never be managed by the shared / unique pointer, which ultimately results in resource leaks. 

This problem can be avoided by using the `std::make_shared` or `std::make_unique` function.

## Disadvantages of using make functions

Even though make functions are preferred in most cases, there are scenarios where they cannot or should not be used. 

Make functions do not support custom deleters, which might be needed. 

Make functions perfect forward their parameters through the non-`std::initializer_list` constructor, however, if we needed it to use the `std::initializer_list` constructor of a given object, then we must use `new` directly. **Braced initializers cannot be perfect forwarded** ... without applying some tricks. 

Automatic type deduction may be used to create an std::initializer_list, such as the following: 
```
auto initList = {1, 2};
auto shp = std::make_shared<std::vector<int>> (initList);
```


