# Define special member function in implementation file, when using Pimpl Idiom

Usually, classes are defined in a header file, and its member functions in a separate implementation file. If a certain class uses another user defined class as a member, then its header must be included in the header file. If the included header file is prone to change frequently, then all client code (that includes the said header file) *must be recompiled* recursively. This may cause an unncessarily big compilation time.

A class can have a pointer to an *incomplete type*, aka a pre-declared class / struct, which then can be defined in the implementation file.

In `commit#:b233287a14949d58bd2b76061a90b4737ab87fe3` we can see that Class includes person.h. This should not be the case, since none of the Person objects are dereferenced or called with its member functions. Therefore, it can be declared as a pointer inside the class declaration. Furthermore, this can be generalized to all data members of the Class data members. We can declare an implementation structure that will contain all of the data members of Class.

We can see an example of implementing the pimpl idiom using a raw pointer in `commi#:a6c0d797e5aa1502d8c77c6a09d617d90bb0ceb6`. However, based on what we did in the previous chapters, we should avoid using raw poitners, and use smart pointers to implement the Pimpl idiom.

Refactoring the raw pointer to an `std::unique_ptr` is very easy. Sadly, there is one problem that arises when trying to use the class (that wraps around our impl struct) in client code. The code fails to compile. When our object goes out of scope, its destructor is called on the object. Within that destructor, another default destructor is also generated for our unique pointer. This inner default deleter function contains a `statis_assert`, which checks if the pointed object is of an incomplete type (memory: line 2536 MSVC v142, inside the `default_delete::operator()` method). The generated destructor is implicitly inline. The key to fixing this issue is for the compiler to see the actual dsetructor of our object **only inside the implementation file**.

We saw earlier that we **must** explicitly define a destructor, if we wish to use a unique pointer in out pimpl designed class. On the attached diagram on the main `README` of this repository, we can see that doing so, the compiler will not generate move operations for our class, however, classes with `std::unique_ptr`s as members should generally support this operation. (Since `std::unique_ptr` can only be moved.) Delcaring the move operations "the easy way" would result in the same compilation error as we saw previously. Therefore, the move operations need to be defined in the implementation file.

Despite having a unique pointer member, the rest of the data members imply that our class should also have copy operations. Since the unique pointer member is a move-only type, we need to define the copy operations manually, and perform a deep copy on the unique pointer.

Using `std::shared_ptr<T>` instead of `std::unique_ptr<T [, deleter]>` we would find that none of the special member functions above need to be explicitly declared, and the code would still do what we want. The main difference is the fact that unique pointers contain the possibility of having a custom deleter in their type declarations, which complicate things. Shared pointers do not. Unique pointers generate smaller and faster code, while having to explicitly declare the special member functions in their approproate places - while using shared pointers generate larger and slower code, but without the "headaches" of having to deal with the special member functions.
